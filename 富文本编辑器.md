slate wangeditor Quil CKEditor5 各个编辑器的实现，区别，多包库，各个包都是做什么的，数据模型是怎样的，如何和视图结合起来的，写个小DEMO；
L2编辑器，看之前的L2的文章；

# wangeditor
## 获取内容

获取HTML和Text：

    editor.getHtml();
    editor.getText();

获取JSON:

JSON格式可以转换为HTML和Text格式，如果在nodejs中，需要安装*yarn add jsdom global-jsdom* 并引入*require('global-jsdom/register')*。

    const editor=createEditor({content}) //'content'即为JSON内容
    const html=editor.getHtml()
    const text=editor.getText()

## 设置内容
设置HTML

创建时设置HTML

    const editor=createEditor({
        html:'<p>hello <strong>world</strong></p>'
    }) 

动态设置HTML

    editor.setHtml('<p>hello <strong>world</strong></p>')

设置Text
    //把text转换为html
    const text='...' //text内容
    const html=text.split(/\n/).map(line=>`<p>${line}</p>`).join('\n')

    //设置html
    const editor=createEditor({
        html,
    })

设置JSON

    const editor=createEditor({
        content:[...], //editor.children 获取的内容
    })

AJAX异步设置内容

可等待Ajax返回之后再创建编辑器

    import {IDomEditor} from '@wangeditor/editor'

    let editor:IDomEditor|null=null

    ajax(url,res=>{
        editor=createEditor({
            //content或html
        })
    })

# L1.5
在L1的基础上，实现跨块选区，
考虑因素：计算光标位置，分词断句，单向数据流、

# 编辑流程看Docs文档架构
## 文档核心编辑流程
用户操作触发编辑行为，行为被抽象成指令集合，用于更新数据模型，最终体现在视图模型。
## 相对完备的Docs在线文档，应具备如下几个基本的条件
数据模型
设计数据模型，通过简单的方式区分不同数据模型在视觉上是否相同
抽象的编辑行为和指令
定义表现良好的编辑行为（Edit），通过发布指令（command）来更新数据模型
用户操作和编辑行为的绑定
转换全部用户操作*Action*为相应编辑行为的序列
视图和数据模型之间的映射关系
建立视图模型*View*与数据模型之间的映射关系，使视图模型能将数据模型的变化在页面上完美呈现
扩展能力
具备足够稳定相对简单的业务迭代能力，如插件机制*Plugins*

## 数据模型
数据特征的抽象，抽象描述系统的静态特征，动态行为和约束条件
### 数据结构
实体*entity*数据类型
结构： 
    {
        spacers:"这是一段简简单单的文本\n",
        styleMap:{
            textStyle:{
                2:{
                    backgroundColor:"#000000",
                },
                4:{
                    bold:true,
                    backgroundColor:"#000000",
                },
                8:{
                    bold:false
                },
                9:{
                   italics:true
                }
            },
            paragraphStyle:{
                0:{
                    lineSpace:1.15
                }
            }
        }
    }
通过数据模型来存储整个文档的内容*spacers*和样式*style*
### 数据操作
数据模型中数据操作主要描述在相应数据结构上的操作类型和操作方式
    class Model {
        constructor(){
            this.spacers='';
            this.styleMap=createDefaultStyle();
        }
        insertSpacers(){
            //插入字符
        }
        deleteSpacers(){
            //删除字符
        }
        applyStyle(){
            //修改样式
        }
    }
如此，构建了对数据模型中Spacers和Style的操作能力。之后需要一个能体现用户本次编辑操作的最小集，能够清晰明确的表达本次编辑操作改变了什么，不仅用于更新model，也用于与服务端交互。
Model通过何种形式给外部提供修改自身的能力--指令
### 指令
Model层的更新统一收口，提供类似Reducer的能力给外部提供修改Model的方法--applyCommand
    class Model{
        constructor(){
            this.spacers='';
            this.currentStyle=createDefaultStyle();
        }
        applyCommand(command){
            switch(command.getType()){
                case :'insert-spacers':
                    this.insertSpacers(command);
                    break;
                case :'delete-spacers':
                    this.deleteSpacers(command);
                    break;
                case :'apply-style':
                    this.applyStyle(command);
                    break;
                
            }
        }
        insertSpacers(){
            //插入字符
        }
        deleteSpacers(){
            //删除字符
        }
        applyStyle(){
            //修改样式
        }
    }
这些 Commands 会被 Model 消费并吸收，同时同步给后端，进而通过 socket 分发给其他协同者。

## 控制器
### 浏览器事件拦截
需要拦截用户的输入操作来达到编辑文档的目的，Docs文档在页面中隐藏了一个contenteditable的元素，这个元素被称为TextEventTarget,通过拦截该元素的一系列浏览器事件（KeyDown、Copy、Paste等）来解析用户的目的。

### 用户操作

拦截操作后，需要组织一些动作（ Action ）来管理这些用户输入。也可以监听Model的变更来决定自身的属性，如enable、visible

### 编辑行为

Action会将一部分操作转移给编辑行为来处理，即改变文档数据模型的行为，每个Edit都会调用上一章提到的Model的applyCommand方法，并将一条或多条Command作为参数传递过去，从而完成数据模型的变更。

直接改变Model层数据的行为可穷举，所以可以进一步将Edit拆分成原子操作（Operations）。原子操作是一系列可以组合使用并最终派发除Command的最底层逻辑，理论上可以覆盖所有的编辑场景。

Docs 文档中共有52种 Operations，通过组合使用，可以满足现有功能的所有编辑操作。

可以通过迅速组合不同的Operations来定义新的Edit。

### 撤销和重做

Edit在每次派发Commands时，会根据某个Command计算出相应的undoCommand并维护在undoStack中，以便用户触发撤销操作时，Model能快速做出反应，消费undoCommand。重做也是这个原理

### 服务端通信

Commands是文档内容变化的最小尺度。Edit通过派发Commands改变了Model的同时，将一个编辑周期内产生的所有Commands组合起来并发送给服务端。

## 视图模型

根据文档的内容进行一些计算，如：可用宽度、可用高度、是否换页/分页等。将一系列计算视图如何展示的流程称为『排版引擎』。

视图模型以容器（view）为单位，包含片段（segment）和组件（renderer）

### 容器

当Model更新完，会派发一个Flush，RootView会监听Flush事件，并从上到下触发所有View的layout计算，包含View所占宽高，是否分页等信息，这些信息影响View最终呈现，如是否分页影响View会分成几个segment来呈现。

在layout的过程中，View还会给每个Segment派发task，在所有View的layout完成后，每个Segment的renderer会消费所有的task，转换为DOM操作。

### 片段

Segment，某个View在某页的一个片段。可以帮助缓存数据、进行光标定位以及维护任务队列

是Docs文档排版引擎的关键，可以更清晰的存储View的展示信息。

### 组件
直接呈现在用户面前的DOM结构，和Segment属于一一对应的关系。
有如下能力：
- 创建DOM,并append到ParentDOM下；
- 组件本身可能是Controller的一部分，需要监听，取消监听一些相应的事件；
- 消费layout产生的task

# 编辑器分类及Docs文档的排版

L2和其他编辑器最大的区别就是排版（layout）
## 排版引擎

### 容器（view）

文档的全部内容都被View掌控着。
View分别维护着自己所需的各种信息。这些信息大部分来自layout

### 排版原理

View分别维护着自己所需的各种信息。其中最重要的信息是尺寸（size）
View的最小颗粒度是Spacer，Docs文档如何获取它的尺寸？
    假设输入a，Docs会在屏幕外绘制一个“a”，将相关样式都付给它，然后测量它的宽度和高度，将测量值与光标的x和y位置结合起来，将“a”放在屏幕上的正确位置。

L2编辑器最大限度的磨平了浏览器之间的差异

### 排版流程

Model 中维护的 RangeLists 会被 View 不断消化，RangeList 清空也代表着本次 layout 完全结束。layout 的核心任务是：获取 View 的尺寸，预判页面将要发生什么样的改变，并将相应的任务派发给 Renderer 用以修改视图。

## 呈现
 排版时会给呈现层（Renderer）派发任务，故Renderer需要消费这些任务，以改变页面的呈现。
 两个思路：DOM或canvas
 目前使用DOM
