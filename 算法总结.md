# 算法

## 回溯算法

## 代码回忆录讲解回溯

回溯和递归相辅相成

递归函数的下面部分就是回溯的逻辑

回溯函数就是指递归函数

回溯搜索法 效率，暴力解法

解决问题： 组合不强调顺序，排列强调元素顺序 组合12 排列12 21

- 组合  1234 找出和为4的组合
- 切割  字符串有几种切割方式，或者加以条件，有几种切割方式 可以保证子串是回文子串
- 子集 1234  1 2 3 4 12 13 14 23 24 34 123 124 234 等列出子集
- 排列 12 21
- 棋盘 N皇后 解数独

可以抽象为n叉树

树的宽度，就是每个节点处理的集合的大小，一般for循环

树的深度，是递归的深度

```js
//回溯函数 一般没有返回值
//起名为backtracking()
//回溯函数一般参数比较多，可以在后面写逻辑的时候需要什么就添加什么
backtracking(...参数){
	//先是终止条件
	if(终止条件){
		//一般是在叶子节点收集结果，子集是在分支节点收集
		收集结果；
		return；
	}
	//单层搜索逻辑，一般是for循环，用来处理集合的每个元素
	for(本层集合元素，集合大小一般是每个分支节点的子节点个数){
    	//处理节点，得出可以收集的结果
        处理节点
        递归函数
        //回溯操作：举例组合，1，放入2，组合为1 2，
        //进行回溯，把2 弹出，才能放3 组合为 1 3
        回溯操作 
    }
    //正常return
    return
}

```

组合问题：

 					1	2	3	4

​				1		2		3		4

可取	234			34		4  

12 13 14		23 24		34

path 路径，一维数组,是搜索过程中的路径

result 结果 二维数组

参数 n,k,`startInde`

`startIndex`确定每次for开始的位置

终止条件：叶子结点-组合大小为2，`path.length=k`

收集结果：`result.push(path)`

单层逻辑：每一个分支节点处就是一个for循环，`startIndex`就是剩余集合的起始位置，遍历剩余元素 `for(i=startIndex,i<=n.i++)`，单层搜索就要用path收集路径上的元素`path.push(i)` 

```js
for(let startIndex,i<=n;i++){
	//path收集路径
    path.push(i);
    // 收集了之前的路径，在这个节点下，遍历剩下的集合,告诉下一次递归的开始位置 i+1
    backtracking(n,k,i+1);
    //回溯
    path.pop(i)
}
```



回溯三部曲

- 确定递归函数参数和返回值
- 确定终止条件
- 确定单层搜索逻辑（单层递归逻辑）









## 掘金帖子



基本原理递归，找到当前可行的步骤，然后递归探测后续步骤。

设计思路：

1. 全局变量：保存结果
2. 参数设计：递归函数的参数是将上一次操作的合法状态当做下一次操作的初始位置。这里的参数，主要为两种：**状态变量**和**条件变量** （1）状态变量（state）就是最后结果（result）要保存的值（2）条件变量就是决定搜索是否完毕或者合法的值
3. 完成条件：完成条件是决定 状态变量和条件变量在取什么值时可以判定整个搜索流程结束。搜索流程结束有两种含义：**搜索成功**并保存结果和**搜索失败**返回上一次状态。
4. 递归过程：传递当前状态给下一次递归进行搜索。

### 套路模板

```
res=[] //定义全局变量保存结果
state=[]
p,q,r
function back(状态，条件1，条件2，...){
	if(不满足合法条件（剪枝）){
		return
		}
	else if(状态满足最终要求){
		res.push(state)
		return
	}
	//主要递归过程，一般带有循环体或者条件体
	for(满足执行条件)或者if(满足执行条件){
		back(状态，条件1，条件2，...)
	}
	
}
back(状态，条件1，条件2，...)
return res
```

### 使用回溯法明显标志

1. 排列、组合（子集、幂集、字符全排列）。在传值时，对于排列问题是要删掉单个用过的元素；组合问题是删掉前面所有的元素
2. 数组、字符串、给定一个特定的规则，尝试搜索迭代找到某个解
3. 二维数组下的DFS（八皇后，黄金矿工，数独）

- 组合问题：N个数里面按一定规则找出k个数的集合
- 切割问题：一个字符串按一定规则有几种切割方式
- 子集问题：一个N个数的集合里有多少符合条件的子集
- 排列问题：N个数按一定规则全排列，有几种排列方式
- 棋盘问题：N皇后，解数独等等

### 如何使用

例子：131 分割回文串

四步：全局变量、参数设计、完成条件、递归过程4

1. 全局变量：题目是找到可分割的方案，最终结果形式上：[[],[],[],...]
2. 参数设计：（1）状态变量：当前是回文的字符串（2）条件变量：剩余待搜索的字符串，当字符串长度为0，则搜索完毕
3. 完成条件：剩余字符串长度为0
4. 递归条件：在剩余字符串中遍历，如果该串为回文就进行下一次递归，如果非回文就继续搜索

```
const res=[];
const state[];
```





















